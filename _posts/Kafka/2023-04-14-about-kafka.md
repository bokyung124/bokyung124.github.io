---
title: "[kafka] 아파치 카프카 개요와 토픽"
last_modified_at: 2023-04-14T07:02:00-05:00
layout: post
categories:
    - Kafka
excerpt: Inflearn) [데브원영] 아파치 카프카 for beginners
toc: true
toc_sticky: true
author_profile: true
mathjax: true
published: true
---

<https://www.inflearn.com/course/아파치-카프카-입문/dashboard>

<br>

## 🪼 카프카란 무엇인가

### 카프카 이전
- 데이터를 전송하는 `소스 애플리케이션`과 데이터를 받는 `타겟 애플리케이션`
- 처음에는 단방향 통신
- 시간이 지나면서 소스 애플리케이션과 타겟 애플리케이션이 많아지면서 데이터를 조성하는 라인이 매우 복잡해짐
- 소스 애플리케이션과 타겟 애플리케이션이 많아질수록 데이터 라인도 많아짐 -> 배포와 장애에 대응 어려움
- 데이터를 전송할 때 프로토콜 포맷의 파편화 심해짐 -> 유지보수 매우 어려워짐

<br>

### kafka 탄생
- kafka: 이러한 복잡함 해결하기 위한 오픈소스 프로그램
- 소스 애플리케이션과 타겟 애플리케이션의 커플링을 약하게 하기 위해 개발됨
- 소스 애플리케이션 -> kafka -> 타겟 애플리케이션

<img width="684" alt="스크린샷 2023-04-14 오전 7 31 40" src="https://user-images.githubusercontent.com/53086873/231898172-3a25c293-bf94-4f44-aac1-97851648119c.png">

- 소스 애플리케이션에서 보낼 수 있는 데이터 포맷은 거의 제한이 없음
- 카프카의 `Topic` 
    - 각종 데이터를 담음
    - Queue
    - 큐에 데이터를 넣는 `Producer`
    - 큐에서 데이터를 가져가는 `Consumer`
- Producer와 Consumer는 라이브러리로 되어 있어 애플리케이션에서 구현 가능

<br>

- 고가용성 -> 데이터 손실 없이 복구 가능
- 낮은 지연과 높은 처리량을 통해 효과적으로 빅데이터 처리 가능

<br>

## 🪼 카프카 토픽
- 토픽: 데이터가 들어가는 공간
- 여러개 생성 가능
- DB의 테이블이나 파일시스템의 폴더와 유사한 성질
 
 <br>

 <img width="772" alt="스크린샷 2023-04-14 오전 8 14 53" src="https://user-images.githubusercontent.com/53086873/231902678-dc28351e-a7a0-4312-a88b-8cfa93b14081.png">

- 토픽에 프로듀서가 데이터를 넣고, 컨슈머가 데이터 가져감
- 목적에 따라 이름을 가질 수 있음
    - 클릭로그, send sms, location log 등과 같이 무슨 데이터를 담는지 명확하게 명시

<br>

### 카프카 토픽 내부
- 하나의 토픽은 여러 개의 파티션으로 구성
- 파티션 번호는 `0`번부터 시작
- 하나의 파티션은 Queue와 같이 데이터가 파티션 끝부터 쌓임

<br>

#### 파티션 1개
<img width="821" alt="스크린샷 2023-04-14 오전 8 17 44" src="https://user-images.githubusercontent.com/53086873/231902945-5ac3676c-af9a-43bf-95cb-925bb330ee08.png">

- 컨슈머는 0번째부터 데이터 가져감
- 컨슈머가 데이터를 가져가더라도 데이터는 삭제되지 않음
- 파티션에 남은 데이터는 새로운 컨슈머가 붙었을 때 0번부터 또 가져갈 수 있음
    - 컨슈머 그룹이 달라야 함
    - `auto.offset.reset = earlieat`로 설정
    - **동일 데이터를 두 번 처리할 수 있음**

<br>

#### 파티션 2개
<img width="819" alt="스크린샷 2023-04-14 오전 8 21 26" src="https://user-images.githubusercontent.com/53086873/231903404-a5987873-9a79-4e32-97ac-7923fa2610a9.png">

- 데이터가 들어갈 경우 들어갈 파티션 `key`를 지정할 수 있음
    - key가 `null`인 경우 라운드 로빈으로 할당
    - key가 있고, 기본 파티셔너를 사용할 경우 키의 해시값을 구하고, 특정 파티션에 할당

<br>

- 파티션을 늘리는건 가능하지만, 다시 줄일 수는 없기 때문에 주의해서 늘려야 함!
- 늘리는 이유: 파티션을 늘리면 컨슈머의 개수를 늘려서 데이터 처리를 분산시킬 수 있음

<br>

- 데이터 삭제되는 시간은 옵션에 따라 다름 
- 레코드가 저장되는 최대 시간과 크기 지정 가능
    - `log.retention.ms`: 최대 레코드 보존 시간
    - `log.retention.byte`: 최대 레코드 보존 크기(byte)